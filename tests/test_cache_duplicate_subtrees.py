# Copyright 2020 MIT Probabilistic Computing Project.
# See LICENSE.txt

from math import log

import numpy

from sppl.distributions import bernoulli
from sppl.distributions import choice
from sppl.distributions import norm
from sppl.spe import ProductSPE
from sppl.spe import SumSPE
from sppl.spe import spe_cache_duplicate_subtrees
from sppl.transforms import Id

rng = numpy.random.RandomState(1)

W = Id('W')
Y = Id('Y')
X = [Id('X[0]'), Id('X[1]')]
Z = [Id('Z[0]'), Id('Z[1]')]

def test_cache_simple_leaf():
    spe = .5 * (W << norm(loc=0, scale=1)) | .5 * (W << norm(loc=0, scale=1))
    assert spe.children[0] is not spe.children[1]
    spe_cached = spe_cache_duplicate_subtrees(spe, {})
    assert spe_cached.children[0] is spe_cached.children[1]

def test_cache_simple_sum_of_product():
    spe \
        = 0.3 * ((W << norm(loc=0, scale=1)) & (Y << norm(loc=0, scale=1))) \
        | 0.7 * ((W << norm(loc=0, scale=1)) & (Y << norm(loc=0, scale=2)))
    spe_cached = spe_cache_duplicate_subtrees(spe, {})
    assert spe_cached.children[0].children[0] is spe_cached.children[1].children[0]

def test_cache_complex_sum_of_product():
    # Test case adapted from the SPE generated by
    # test_repeat.make_model_repeat(n=2)
    duplicate_subtrees = [None, None]
    for i in range(2):
        duplicate_subtrees[i] = SumSPE([
            ProductSPE([
                (X[0] << bernoulli(p=.1)),
                SumSPE([
                    (Z[0] << bernoulli(p=.5))
                        & (Y << choice({'0':.1, '1': .9})),
                    (Z[0] << bernoulli(p=.1))
                        & (Y << choice({'0':.9, '1': .1}))
                ], weights=[log(.730), log(.270)])
            ]),
            ProductSPE([
                Z[0] << bernoulli(p=.1),
                Y << choice({'0':.9, '1':.1}),
                X[0] << bernoulli(p=.5),
            ]),
        ], weights=[log(.925), log(.075)])

    assert duplicate_subtrees[0] == duplicate_subtrees[1]
    assert duplicate_subtrees[0] is not duplicate_subtrees[1]

    left_subtree = ProductSPE([
        X[1] << bernoulli(p=.5),
        SumSPE([
            ProductSPE([
                duplicate_subtrees[0],
                Z[1] << bernoulli(p=.5),
            ]),
            ProductSPE([
                Z[1] << bernoulli(p=.7),
                SumSPE([
                    Y << choice({'0':.3, '1':.7})
                        & X[0] << bernoulli(p=.1)
                        & Z[0] << bernoulli(p=.1),
                    Y << choice({'0':.7, '1':.3})
                        & X[0] << bernoulli(p=.5)
                        & Z[0] << bernoulli(p=.5),
                ], weights=[log(.9), log(.1)])
            ])
        ], weights=[log(.783), log(.217)])
    ])

    right_subtree = ProductSPE([
        Z[1] << bernoulli(p=.8),
        X[1] << bernoulli(p=.1),
        duplicate_subtrees[1]
    ])

    spe = .92 * left_subtree | .08 * right_subtree

    spe_cached = spe_cache_duplicate_subtrees(spe, {})
    assert spe_cached.children[0].children[1].children[0].children[0] is duplicate_subtrees[0]
    assert spe_cached.children[1].children[2] is duplicate_subtrees[0]
