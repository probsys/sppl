Probabilistic Programming with Sum-Product Networks
===================================================

The Kernel Language
-------------------

Domain Variables

  n âˆˆ Naturals
  r âˆˆ Reals
  w âˆˆ [0,1]
  s âˆˆ Strings
  x âˆˆ Var

Transform Data Type

  i âˆˆ InfiniteSet
    = Interval(râ‚, râ‚‚)                      // [râ‚, râ‚‚]
    | Interval.open(râ‚, râ‚‚)                 // (râ‚, râ‚‚)
    | Interval.Lopen(râ‚, râ‚‚)                // (râ‚, râ‚‚]
    | Interval.Ropen(râ‚, râ‚‚)                // [râ‚, râ‚‚)

  f âˆˆ FiniteSet
    = EmptySet                              // âˆ…
    | FiniteSetReal(râ‚, â€¦, râ‚˜)              // {râ‚, â€¦, râ‚˜}
    | FiniteSetNominal(sâ‚, â€¦, sâ‚˜)           // {sâ‚, â€¦, sâ‚˜}

  v âˆˆ Set
    = i
    | f
    | Union([vâ‚, â€¦, vâ‚˜])                    // vâ‚ âˆª â€¦ âˆª vâ‚˜
    | Complement f                          // (by cases)

  t âˆˆ Transform
    = Identity(x)                           // x               one-to-one
    | Reciprocal(t)                         // 1 / t(x)        one-to-one
    | Radical(t, n)                         // â¿âˆšt(x)          one-to-one
    | Exponent(t, r)                        // ráµ—â½Ë£â¾           one-to-one
    | Logarithm(t, r)                       // logáµ£(t(x))      one-to-one
    | Abs(t)                                // |t(x)|          many-to-one
    | Polynomial(t, [râ‚€, â€¦, râ‚˜])            // âˆ‘ráµ¢tâ±(x)        many-to-one
    | Piecewise([tâ‚, â€¦, tâ‚˜], [eâ‚, â€¦, eâ‚˜])   // âˆ‘I[eáµ¢(x)]táµ¢(x)  many-to-one

  e âˆˆ Event <: Transforms
    = EventBasic(t, v)                      // {t(x) âˆˆ v} = {y|t(y) âˆˆ v}
    | EventOr([eâ‚, â€¦, eâ‚˜])                  // eâ‚ âˆ¨ â€¦ âˆ¨ eâ‚˜
    | EventAnd([eâ‚, â€¦, eâ‚˜])                 // eâ‚ âˆ§ â€¦ âˆ§ eâ‚˜
    | EventNot(e)                           // ~e

  invert              :: Transform â†’ Set â†’ Set
  solve               :: Event â†’ Set
  simplify            :: Event â†’ Event

SPN Type

  F âˆˆ â„œ â†’ [0,1]  (a CDF, i.e., F(x) = Î¼((-âˆ, x]), and cadlag)

  d âˆˆ Distribution
    = Nominal {sáµ¢: páµ¢ âˆ£ i=1, â€¦, m}        // Î¼({sáµ¢}) = páµ¢
    | RealAtomic i F                      // Î¼(i) := F(i) - F(i-1)
    | RealContinuous i F                  // Î¼((-âˆ, x]) = F(x)

  s âˆˆ SPN
    = (â„“ x d)                   [Leaf]
    | (âŠ— sâ‚ â€¦ sâ‚˜)               [Product]
    | (âŠ• (wâ‚ sâ‚) â€¦ (wâ‚™ sâ‚˜))     [Sum]

The denotation of an SPN is a probability measure.
The scope function returns the set of distinct symbols in s:

  scope :: SPN â†’ {Vars}
  scope(â„“ x d) = {x}
  scope(âŠ— sâ‚ â€¦ sâ‚˜) = âˆªáµ¢ scope(sáµ¢)
  scope((âŠ• (wâ‚ sâ‚) â€¦ (wâ‚™ sâ‚˜))) = âˆªáµ¢ scope(sáµ¢)

Let n = |scope(s)|.

  ğâŸ¦.âŸ§ :: SPN â†’ Ïƒ[(R âŠ S)â¿] â†’ [0, 1]

  Ïƒ(R âŠ S) := B(R âŠ S)
  The Borel sigma algebra on the disjoint union topological space,
    where R is given the usual topology,
    and S is given the discrete topology.

  Semantic functions on SPN

  [Probability]         ğâŸ¦.âŸ§ :: SPN â†’ Event â†’ [0,1]
  [Condition]           ğ‚âŸ¦.âŸ§ :: SPN â†’ Event â†’ SPN
  [Mutual Information]  ğŒâŸ¦.âŸ§ :: SPN â†’ Event â†’ Event â†’ Reals

- Give a denotational semantics of the kernel language
- Give a small-step operational semantics for the modeling language.

The Modeling Language
---------------------

Also known as the "syntactic sugar"

y âˆˆ ArrVar
z âˆˆ Vars = x | y[n]

  t âˆˆ Transformations
    = x                         [Identity]
    | 1/t                       [Reciprocal]
    | â¿âˆšt                       [Radical]
    | ráµ—                        [Exp]
    | log(t, r)                 [Log]
    | abs(t)                    [Abs]
    | râ‚€ + râ‚t + â€¦ + râ‚˜táµ       [Polynomial]
    | Ï•â‚tâ‚ + Ï•â‚‚tâ‚‚ + ... + Ï•â‚™tâ‚™  [Piecewise]

  f âˆˆ FiniteOutcomes :=
    | {râ‚, â€¦, râ‚˜}               [RealFinite]
    | {sâ‚, â€¦, sâ‚˜}               [NominalFinite]

  c âˆˆ Comparison = < | <=
  Ï• âˆˆ Predicate :=
    | t c r                 [Less]
    | r c t                 [Greater]
    | t << f                [Containment]
    | Ï•â‚ & Ï•â‚‚               [Conjunction]
    | Ï•â‚ | Ï•â‚‚               [Disjunction]
    | ~Ï•                    [Negation]

  d âˆˆ Dist
    = Nominal {sáµ¢:páµ¢ âˆ£ i=1, â€¦, m}   [NominalDist]
    | Normal Î¼ Î½ | â€¦                [ContinuousDist]
    | Poisson Î» | â€¦                 [DiscreteDist]
    | wâ‚*dâ‚ + wâ‚‚*dâ‚‚                 [MixtureDist]

  c âˆˆ Program
    = y â† array(n)                                  [DeclareArr]
    | z ~ d                                         [Sample]
    | z â† t                                         [Transform]
    | câ‚ ; câ‚‚                                       [Sequence]
    | if Ï•â‚ then câ‚ elif Ï•â‚‚ then câ‚‚ â€¦ else câ‚™       [Condition]
    | repeat n n' Î»i.c                              [Repeat]

Small Step Semantics

  The semantics of a program c âˆˆ Program is a
  sum-product network s âˆˆ SPN.

  We will describe the mapping from the syntactic domain
  to the semantic domain using SOS.

  More specifically, the program state is a pair (s, Ïƒ) where
    Ïƒ âˆˆ Vars â†’ Transforms
    s âˆˆ SPN

  For any predicate Ï• âˆˆ Predicate and environment Ïƒ, define
    Ï•[Ïƒ] = case Ï• of
      t in v    | var(t) âˆˆ Ïƒ -> [Ïƒ[var(t)]] in v
                | otherwise -> Ï•
      Ï•â‚ and Ï•â‚‚ -> (Ï•â‚[Ïƒ] and Ï•â‚‚[Ïƒ])
      Ï•â‚ or Ï•â‚‚ -> (Ï•â‚[Ïƒ] or Ï•â‚‚[Ïƒ])
      ~Ï• -> ~Ï•[Ïƒ]


[Sample]  ----------------------------------
          âŸ¨(s, Ïƒ), x ~ dâŸ© â†’ (âŠ— s (â„“ x d), Ïƒ[x\Identity(x)])

[Transform]  -----------------------------
             âŸ¨(s, Ïƒ), z â† tâŸ© â†’ (s, [z\t]Ïƒ)

             âŸ¨(s, Ïƒ), câ‚ â†’ (sâ‚, Ïƒâ‚)  âŸ¨(sâ‚, Ïƒâ‚), câ‚‚ â†’ (sâ‚‚, Ïƒâ‚‚)
[Sequence]   ------------------------------------------------
                      âŸ¨(s, Ïƒ), câ‚;câ‚‚âŸ© â†’ (sâ‚‚, Ïƒâ‚‚)

          âŸ¨(s|Ï•[Ïƒ], Ïƒ), câ‚âŸ© â†’ (sâ‚, Ïƒâ‚) âŸ¨(s|~Ï•[Ïƒ], Ïƒ), câ‚‚âŸ© â†’ (sâ‚‚, Ïƒâ‚‚)
[IfElse]  -----------------------------------------------------------
          âŸ¨(s, Ïƒ), if Ï• then câ‚ else câ‚‚âŸ© â†’ âŠ• (ğâŸ¦sâŸ§(Ï•[Ïƒ])) (sâ‚, Ïƒâ‚)
                                             (1-ğâŸ¦sâŸ§(~Ï•[Ïƒ])) (sâ‚‚, Ïƒâ‚‚)

[Repeat-False]
      --------------------------------  (where n' <= n)
      âŸ¨(s, Ïƒ), repeat n n' Î»x.câŸ© â†’ (s, Ïƒ)

[Repeat-True-v1]

    ------------------------------------------------------------  (where n < n')
    âŸ¨(s, Ïƒ), repeat n Î»x.câŸ© â†’ âŸ¨(s, Ïƒ), ( (Î»x.c)(n); repeat (n+1) n' Î»x.c)âŸ©

[Repeat-True-v2]

    âŸ¨(s,Ïƒ), [x\n]câŸ© â†’ (s', Ïƒ')  âŸ¨(s',Ïƒ'), repeat (n+1) n' Î»x.câŸ© â†’ (s'', Ïƒ'')
    ------------------------------------------------------------  (where n < n')
    âŸ¨(s, Ïƒ), repeat n Î»x.câŸ© â†’ (s'', Ïƒ'')

    The notation [x\n]c means:

      syntactically replace every instance of variable x with the numeral
      n in the expression c.
