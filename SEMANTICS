Probabilistic Programming with Sum-Product Networks
===================================================

Domain Variables

  n âˆˆ Naturals
  r âˆˆ Reals
  w âˆˆ [0,1]
  s âˆˆ Strings
  x âˆˆ Vars

Transform Data Type (Semantic Domain)

  i âˆˆ InfiniteSet
    = Interval(râ‚, râ‚‚)
    | Interval.open(râ‚, râ‚‚)
    | Interval.Lopen(râ‚, râ‚‚)
    | Interval.Ropen(râ‚, râ‚‚)

  f âˆˆ FiniteSet
    = EmptySet
    | FiniteSetReal(râ‚, â€¦, râ‚˜)
    | FiniteSetNominal(sâ‚, â€¦, sâ‚˜)

  v âˆˆ Sets := i | f | Union([vâ‚, â€¦, vâ‚˜]) | Complement f

  g âˆˆ Transform
    = Identity(x)                           // One-to-One
    | Reciprocal(g)                         // One-to-One
    | Radical(g, n)                         // One-to-One
    | Exponent(g, r)                        // One-to-One
    | Logarithm(g, r)                       // One-to-One
    | Abs(g)                                // Many-to-One
    | Polynomial(g, [râ‚€, â€¦, râ‚˜])            // Many-to-One
    | Piecewise([gâ‚, â€¦, gâ‚˜], [eâ‚, â€¦, eâ‚˜])   // Many-to-One

  e âˆˆ Event <: Transforms                   // Many-to-One
    = EventInterval(t, i)
    | EventFinteReal(t, [râ‚, â€¦, râ‚˜])
    | EventFiniteNominal(t, [sâ‚, â€¦, sâ‚˜])
    | EventOr([eâ‚, â€¦, eâ‚˜])
    | EventAnd([eâ‚, â€¦, eâ‚˜])

  invert              :: Transform -> Sets -> Sets
  solve               :: Event -> Sets

SPN Type (Semantic Domain)

  Î¸ âˆˆ CDF
  d âˆˆ Distribution
    = Nominal {sáµ¢:páµ¢ âˆ£ i=1, â€¦, m}
    | RealContinuous Î˜
    | RealDiscrete Î¸

  s âˆˆ SPN
    = (â„“ x d)                   [Leaf]
    | (âŠ— sâ‚ â€¦ sâ‚˜)               [Product]
    | (âŠ• (wâ‚ sâ‚) â€¦ (wâ‚™ sâ‚˜))     [Sum]

  The denotation of an SPN is a probability measure,
    ğâŸ¦.âŸ§ : SPN -> (e -> [0,1])

  Operations on SPN:
  condition           :: SPN -> e -> SPN
  mutual-information  :: SPN -> eâ‚ -> eâ‚‚ -> Reals

Modeling Language (Syntactic Domain)

  t âˆˆ Transformations
    = x                         [Identity]
    | 1/t                       [Reciprocal]
    | â¿âˆšt                       [Radical]
    | ráµ—                        [Exp]
    | logáµ£(t)                   [Log]
    | abs(t)                    [Abs]
    | râ‚€ + râ‚t + â€¦ + râ‚˜táµ       [Polynomial]
    | Ï•â‚tâ‚ + Ï•â‚‚tâ‚‚ + ... + Ï•â‚™tâ‚™  [Piecewise]

  f âˆˆ FiniteOutcomes :=
    | {râ‚, â€¦, râ‚˜}               [RealFinite]
    | {sâ‚, â€¦, sâ‚˜}               [NominalFinite]

  Ï• âˆˆ Predicate :=
    | t < r                 [LessThan]
    | t <= r                [LessThanEquals]
    | r < t                 [GreaterThan]
    | r <= t                [GreatherThanEquals]
    | t << f                [Containment]
    | Ï•â‚ & Ï•â‚‚               [Conjunctio]
    | Ï•â‚ /| Ï•â‚‚              [Disjunction]
    | Ï•â‚ ^ Ï•â‚‚               [XOR]
    | ~Ï•                    [Negation]

  d âˆˆ Dist
    = Nominal {sáµ¢:páµ¢ âˆ£ i=1, â€¦, m}   [NominalDist]
    | Normal Î¼ Î½ | â€¦                [ContinuousDist]
    | Poisson Î» | â€¦                 [DiscreteDist]
    | wâ‚*dâ‚ + wâ‚‚dâ‚‚                    [MixtureDist]

  c âˆˆ Program
    = x ~ d                     [Sample]
    | x â† t                     [Assign]
    | if Ï• then câ‚ else câ‚‚      [If-Else]
    | câ‚ ; câ‚‚                   [Sequence]

Small Step Semantics

  The semantics of a program c âˆˆ Program is a
  sum-product network s âˆˆ SPN.

  We will describe the mapping from the syntactic domain
  to the semantic domain using SOS.

  More specifically, the program state is a pair (s, Ïƒ) where
    Ïƒ âˆˆ Vars â†’ Transforms
    s âˆˆ SPN

  For any predicate Ï• âˆˆ Predicate and environment Ïƒ, define
    Ï•[Ïƒ] = case Ï• of
      t in v    | var(t) âˆˆ Ïƒ -> [Ïƒ[var(t)]] in v
                | otherwise -> Ï•
      Ï•â‚ and Ï•â‚‚ -> (Ï•â‚[Ïƒ] and Ï•â‚‚[Ïƒ])
      Ï•â‚ or Ï•â‚‚ -> (Ï•â‚[Ïƒ] or Ï•â‚‚[Ïƒ])
      ~Ï• -> ~Ï•[Ïƒ]

[Sample]  ----------------------------------
          âŸ¨(s, Ïƒ), x ~ dâŸ© â†’ (âŠ— s (â„“ x d), Ïƒ)

[Assign]  -----------------------------
          âŸ¨(s, Ïƒ), x â† tâŸ© â†’ (s, [x\t]Ïƒ)

          âŸ¨(s|Ï•[Ïƒ], Ïƒ), câ‚âŸ© â†’ (sâ‚, Ïƒâ‚) âŸ¨(s|~Ï•[Ïƒ], Ïƒ), câ‚‚âŸ© â†’ (sâ‚‚, Ïƒâ‚‚)
[IfElse]  -----------------------------------------------------------
          âŸ¨(s, Ïƒ), if Ï• then câ‚ else câ‚‚âŸ© â†’ âŠ• (ğâŸ¦sâŸ§(Ï•[Ïƒ])] (sâ‚, Ïƒâ‚))
                                             (1-ğâŸ¦sâŸ§(~Ï•[Ïƒ])) (sâ‚‚, Ïƒâ‚‚))

             âŸ¨(s, Ïƒ), câ‚ â†’ (sâ‚, Ïƒâ‚)  âŸ¨(sâ‚, Ïƒâ‚), câ‚‚ â†’ (sâ‚‚, Ïƒâ‚‚)
[Sequence]   ------------------------------------------------
                      âŸ¨(s, Ïƒ), câ‚;câ‚‚âŸ© â†’ (sâ‚‚, Ïƒâ‚‚)
